# BigData Project SPbU  
## Task 2  
1.	Нужно сгенерировать файл, содержащий 2000 128-битных случайных целых чисел, каждое число на отдельной строке.  
2.	Посчитать, какое суммарное количество простых множителей присутствует при факторизации всех чисел. Например, пусть всего два числа: 6 и 8. 6 = 2 * 3, 8 = 2 * 2 * 2. Ответ 5. При реализации нужно использовать операции с длинной арифметикой (BigInteger и т.д.)  
3.	Реализовать подсчет  
- простым последовательным алгоритмом  
- многопоточно, с использованием примитивов синхронизации  
- с помощью Akka или RxJava   
4.	Измерить время выполнения для каждого случая. Использовать уровень параллельности в соответствии с числом ядер вашего CPU.  
### Реализация  
Суммарное количество простых множителей считается с помощью рекурсивной функции factorization. Идея заключается в том, что мы:  
1.  Ищем простое число и проверяем, делится ли нацело на это число наше текущее число  
	  - Если делится, тогда добавляем текущее простое число в список множителей, на которые мы раскладываем текущее число – fact – и рекурсивно применяем нашу функцию к остатку
	  - Если не делится, тогда рассматриваем следующее простое число  
2.  Получаем список, каждым элементом которого является список множителей, на которые мы разложили каждое число.  
3.  Ответ – перебор каждого списка и подсчет количества элементов соответственно.    

Данный алгоритм является базовым для решения основной задачи.  
Второстепенная задача заключалась в оптимизации скорости вычислений.
##### Варианты:
  1.  **Последовательное вычисление:** просто перебираем элементы списка и передаем их в качестве аргумента в функцию factorization
  2.  **Использование многопоточности по примитиву синхронизации.**  
    Здесь все основано на идее, что в один момент времени только один поток может иметь доступ к исходному массиву чисел. 
    Поэтому мы:   
      1.  блокируем все остальные потоки: **acquire()**
      2.  забираем текущее число
      3.  кладем его во вспомогательный список listFrom 
      4.  удаляем его из текущего списка (чтобы следующий поток брал уже следующее число).
      5.  finally – берем число из вспомогательного списка
      6.  Говорим другим потокам, что данные доступны для чтения: **release()**
      7.  Пока другой поток забирает число, текущий поток производит вычисления и заносит данные в глобальный список результатов list
      Если в исходном списке уже не осталось чисел (потоки все забрали), раздача заданий для потоков закончена. 
  3.  **Фреймворк Akka** 
   
В основе данного подхода лежит работа с акторами. Идея заключается в том, что у нас есть  один главный актор и второстепенный. Главный актор получает сообщение (что нужно сделать) и передает ему второстепенному. Многопоточность здесь заключается в следующем:   
1.  Задаем количество потоков текущего актора: **actorsCount**
2.  Разбиваем исходный массив данных на actorsCount равных частей
3.  Передаем **actorsCount** сообщений второстепенному актору – **DownloaderActor**
Данные сообщения обрабатываются параллельно с использованием actorsCount потоков. То есть, одному сообщению ставится в соответствие один поток.
Когда расчеты окончены, сообщаем об этом: context.system.terminate()
Окончание работы всех потоков определяется за счет: system.whenTerminated
В ходе работы тестировалось разное количество потоков. Видно, что использование семафора и Akka увеличивают скорость вычислений.

###Результаты:
  Для теста было выбрано 6 потоков и 2000 чисел.  
**Последовательный алгоритм**: 56543 мс = 56,54 c.  
**Семафор**: 22032 мс = 22,03 c.  
**Akka**: 25595 мс =  25,59 c.  

Видно, что использование многопоточности в два раза увеличило скорость вычислений.
